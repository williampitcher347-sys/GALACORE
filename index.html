<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Galaxacord</title>
<meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Firebase -->
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>

<style>
/* ========== GLOBAL ========== */
* { box-sizing: border-box; font-family: Arial, sans-serif; }
body {
  margin: 0;
  background: #1e1f22;
  color: white;
  height: 100vh;
  overflow: hidden;
}

/* ========== LAYOUT ========== */
#app {
  display: grid;
  grid-template-columns: 70px 240px 1fr 240px;
  height: 100vh;
}

/* ========== SERVERS ========== */
#servers {
  background: #1e1f22;
  padding: 10px;
}
.server {
  width: 50px;
  height: 50px;
  border-radius: 50%;
  background: #313338;
  display: flex;
  align-items: center;
  justify-content: center;
  margin-bottom: 10px;
}

/* ========== CHANNELS ========== */
#channels {
  background: #2b2d31;
  padding: 10px;
}
.channel {
  padding: 6px;
  cursor: pointer;
}
.channel:hover {
  background: #3a3c43;
}
#voiceStatus {
  font-size: 12px;
  opacity: 0.8;
}

/* ========== CHAT ========== */
#chat {
  background: #313338;
  display: flex;
  flex-direction: column;
}
#messages {
  flex: 1;
  overflow-y: auto;
  padding: 10px;
}
.message {
  margin-bottom: 6px;
}
#inputBar {
  display: flex;
  padding: 10px;
  gap: 5px;
}
#inputBar input {
  flex: 1;
  padding: 8px;
}

/* ========== USERS ========== */
#users {
  background: #2b2d31;
  padding: 10px;
}
.user {
  padding: 4px;
}

/* ========== BUTTONS ========== */
button {
  background: #5865f2;
  border: none;
  padding: 8px;
  color: white;
  cursor: pointer;
}
button.red {
  background: #ed4245;
}
</style>
</head>

<body>

<div id="app">

  <!-- SERVERS -->
  <div id="servers">
    <div class="server">ðŸŒŒ</div>
  </div>

  <!-- CHANNELS -->
  <div id="channels">
    <h4>TEXT</h4>
    <div class="channel"># global</div>

    <h4>VOICE</h4>
    <div class="channel" onclick="joinVoice('vc1')">ðŸ”Š VC 1</div>
    <div class="channel" onclick="joinVoice('vc2')">ðŸ”Š VC 2</div>

    <div id="voiceStatus">Not in voice</div>
    <button class="red" onclick="leaveVoice()">Disconnect</button>

    <hr>

    <input id="nameInput" placeholder="Username">
    <button onclick="saveName()">Save Name</button>
    <button onclick="toggleMute()">Mute / Unmute</button>
  </div>

  <!-- CHAT -->
  <div id="chat">
    <div id="messages"></div>
    <div id="inputBar">
      <input id="msg" placeholder="Message">
      <button onclick="send()">Send</button>
    </div>
  </div>

  <!-- USERS -->
  <div id="users">
    <h4>Online</h4>
    <div id="userList"></div>
  </div>

</div>

<script>
/* ================= FIREBASE ================= */
firebase.initializeApp({
  apiKey: "AIzaSyBt_mZIfYnzcMygeQ11OTv1J59ARqsoN2c",
  databaseURL: "https://dcrd3upgraded-default-rtdb.firebaseio.com",
  projectId: "dcrd3upgraded"
});
const db = firebase.database();

/* ================= USER ================= */
let userId = localStorage.getItem("gc_id");
if (!userId) {
  userId = crypto.randomUUID();
  localStorage.setItem("gc_id", userId);
}

let username = localStorage.getItem("gc_name");
if (!username) {
  username = "User" + Math.floor(Math.random() * 9000);
  localStorage.setItem("gc_name", username);
}
document.getElementById("nameInput").value = username;

/* ================= PRESENCE ================= */
db.ref("users/" + userId).set({ username, online: true });

window.onbeforeunload = () => {
  db.ref("users/" + userId).remove();
  leaveVoice();
};

/* ================= TEXT CHAT ================= */
function send() {
  const input = document.getElementById("msg");
  if (!input.value) return;

  db.ref("messages").push({
    user: username,
    text: input.value,
    time: Date.now()
  });

  input.value = "";
}

db.ref("messages").limitToLast(100).on("child_added", snap => {
  const m = snap.val();
  const div = document.createElement("div");
  div.className = "message";
  div.textContent = m.user + ": " + m.text;
  document.getElementById("messages").appendChild(div);
});

/* ================= USERS LIST ================= */
db.ref("users").on("value", snap => {
  const list = document.getElementById("userList");
  list.innerHTML = "";
  snap.forEach(u => {
    const div = document.createElement("div");
    div.className = "user";
    div.textContent = u.val().username;
    list.appendChild(div);
  });
});

/* ================= USERNAME ================= */
function saveName() {
  const v = document.getElementById("nameInput").value.trim();
  if (v.length < 3) return alert("Name too short");
  username = v;
  localStorage.setItem("gc_name", v);
  db.ref("users/" + userId + "/username").set(v);
}

/* ================= VOICE (MULTI-USER WEBRTC) ================= */
let currentRoom = null;
let localStream = null;
let peers = {};
let audioEls = {};
let muted = false;

const rtcConfig = {
  iceServers: [{ urls: "stun:stun.l.google.com:19302" }]
};

async function joinVoice(room) {
  if (currentRoom === room) return;
  leaveVoice();

  currentRoom = room;
  document.getElementById("voiceStatus").textContent = "ðŸ”Š Connecting to " + room;

  localStream = await navigator.mediaDevices.getUserMedia({ audio: true });

  const roomRef = db.ref("voiceRooms/" + room);

  await roomRef.child("members/" + userId).set({ username });

  roomRef.child("members").on("child_added", snap => {
    if (snap.key !== userId) createPeer(snap.key, true);
  });

  roomRef.child("members").on("child_removed", snap => {
    removePeer(snap.key);
  });

  roomRef.child("signals").on("child_added", snap => {
    const data = snap.val();
    if (data.to === userId) handleSignal(data);
  });

  document.getElementById("voiceStatus").textContent = "ðŸ”Š In " + room;
}

function createPeer(peerId, initiator) {
  if (peers[peerId]) return;

  const pc = new RTCPeerConnection(rtcConfig);
  peers[peerId] = pc;

  localStream.getTracks().forEach(t => pc.addTrack(t, localStream));

  pc.ontrack = e => {
    let audio = audioEls[peerId];
    if (!audio) {
      audio = document.createElement("audio");
      audio.autoplay = true;
      audioEls[peerId] = audio;
      document.body.appendChild(audio);
    }
    audio.srcObject = e.streams[0];
  };

  pc.onicecandidate = e => {
    if (e.candidate) {
      sendSignal(peerId, { type: "ice", candidate: e.candidate });
    }
  };

  if (initiator) {
    pc.createOffer().then(offer => {
      pc.setLocalDescription(offer);
      sendSignal(peerId, { type: "offer", sdp: offer });
    });
  }
}

function sendSignal(to, payload) {
  db.ref("voiceRooms/" + currentRoom + "/signals").push({
    from: userId,
    to,
    ...payload
  });
}

async function handleSignal(data) {
  let pc = peers[data.from];
  if (!pc) {
    createPeer(data.from, false);
    pc = peers[data.from];
  }

  if (data.type === "offer") {
    await pc.setRemoteDescription(new RTCSessionDescription(data.sdp));
    const answer = await pc.createAnswer();
    await pc.setLocalDescription(answer);
    sendSignal(data.from, { type: "answer", sdp: answer });
  }

  if (data.type === "answer") {
    await pc.setRemoteDescription(new RTCSessionDescription(data.sdp));
  }

  if (data.type === "ice") {
    await pc.addIceCandidate(new RTCIceCandidate(data.candidate));
  }
}

function removePeer(id) {
  if (peers[id]) peers[id].close();
  if (audioEls[id]) audioEls[id].remove();
  delete peers[id];
  delete audioEls[id];
}

function leaveVoice() {
  if (!currentRoom) return;

  Object.keys(peers).forEach(removePeer);

  if (localStream) {
    localStream.getTracks().forEach(t => t.stop());
    localStream = null;
  }

  db.ref("voiceRooms/" + currentRoom + "/members/" + userId).remove();
  currentRoom = null;
  document.getElementById("voiceStatus").textContent = "Not in voice";
}

function toggleMute() {
  muted = !muted;
  if (localStream) {
    localStream.getAudioTracks().forEach(t => t.enabled = !muted);
  }
}
</script>

</body>
</html>
